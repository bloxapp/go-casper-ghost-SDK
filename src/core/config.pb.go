// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/core/config.proto

package core

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ChainConfig struct {
	// initial values
	GenesisForkVersion []byte `protobuf:"bytes,1,opt,name=GenesisForkVersion,proto3" json:"GenesisForkVersion,omitempty"`
	// Time
	SlotsInEpoch                     uint64 `protobuf:"varint,100,opt,name=SlotsInEpoch,proto3" json:"SlotsInEpoch,omitempty"`
	MinAttestationInclusionDelay     uint64 `protobuf:"varint,101,opt,name=MinAttestationInclusionDelay,proto3" json:"MinAttestationInclusionDelay,omitempty"`
	MaxSeedLookahead                 uint64 `protobuf:"varint,102,opt,name=MaxSeedLookahead,proto3" json:"MaxSeedLookahead,omitempty"`
	MinSeedLookahead                 uint64 `protobuf:"varint,103,opt,name=MinSeedLookahead,proto3" json:"MinSeedLookahead,omitempty"`
	SlotsPerHistoricalRoot           uint64 `protobuf:"varint,104,opt,name=SlotsPerHistoricalRoot,proto3" json:"SlotsPerHistoricalRoot,omitempty"`
	MinValidatorWithdrawabilityDelay uint64 `protobuf:"varint,105,opt,name=MinValidatorWithdrawabilityDelay,proto3" json:"MinValidatorWithdrawabilityDelay,omitempty"`
	MinEpochsToInactivityPenalty     uint64 `protobuf:"varint,106,opt,name=MinEpochsToInactivityPenalty,proto3" json:"MinEpochsToInactivityPenalty,omitempty"`
	EpochsPerETH1VotingPeriod        uint64 `protobuf:"varint,107,opt,name=EpochsPerETH1VotingPeriod,proto3" json:"EpochsPerETH1VotingPeriod,omitempty"`
	ShardCommitteePeriod             uint64 `protobuf:"varint,108,opt,name=ShardCommitteePeriod,proto3" json:"ShardCommitteePeriod,omitempty"`
	// Misc
	MaxCommitteesPerSlot           uint64 `protobuf:"varint,200,opt,name=MaxCommitteesPerSlot,proto3" json:"MaxCommitteesPerSlot,omitempty"`
	TargetCommitteeSize            uint64 `protobuf:"varint,201,opt,name=TargetCommitteeSize,proto3" json:"TargetCommitteeSize,omitempty"`
	MaxValidatorsPerCommittee      uint64 `protobuf:"varint,202,opt,name=MaxValidatorsPerCommittee,proto3" json:"MaxValidatorsPerCommittee,omitempty"`
	ChurnLimitQuotient             uint64 `protobuf:"varint,203,opt,name=ChurnLimitQuotient,proto3" json:"ChurnLimitQuotient,omitempty"`
	VaultSize                      uint64 `protobuf:"varint,204,opt,name=VaultSize,proto3" json:"VaultSize,omitempty"`
	MinPerEpochChurnLimit          uint64 `protobuf:"varint,205,opt,name=MinPerEpochChurnLimit,proto3" json:"MinPerEpochChurnLimit,omitempty"`
	MinGenesisTime                 uint64 `protobuf:"varint,206,opt,name=MinGenesisTime,proto3" json:"MinGenesisTime,omitempty"`
	MinGenesisActiveValidatorCount uint64 `protobuf:"varint,207,opt,name=MinGenesisActiveValidatorCount,proto3" json:"MinGenesisActiveValidatorCount,omitempty"`
	ProportionalSlashingMultiplier uint64 `protobuf:"varint,208,opt,name=ProportionalSlashingMultiplier,proto3" json:"ProportionalSlashingMultiplier,omitempty"`
	HysteresisQuotient             uint64 `protobuf:"varint,209,opt,name=HysteresisQuotient,proto3" json:"HysteresisQuotient,omitempty"`
	HysteresisDownwardMultiplier   uint64 `protobuf:"varint,210,opt,name=HysteresisDownwardMultiplier,proto3" json:"HysteresisDownwardMultiplier,omitempty"`
	HysteresisUpwardMultiplier     uint64 `protobuf:"varint,211,opt,name=HysteresisUpwardMultiplier,proto3" json:"HysteresisUpwardMultiplier,omitempty"`
	ShuffleRoundCount              uint64 `protobuf:"varint,212,opt,name=ShuffleRoundCount,proto3" json:"ShuffleRoundCount,omitempty"`
	// constants
	FarFutureEpoch           uint64 `protobuf:"varint,300,opt,name=FarFutureEpoch,proto3" json:"FarFutureEpoch,omitempty"`
	ZeroHash                 []byte `protobuf:"bytes,301,opt,name=ZeroHash,proto3" json:"ZeroHash,omitempty"`
	GenesisSeed              []byte `protobuf:"bytes,302,opt,name=GenesisSeed,proto3" json:"GenesisSeed,omitempty"`
	GenesisEpoch             uint64 `protobuf:"varint,303,opt,name=GenesisEpoch,proto3" json:"GenesisEpoch,omitempty"`
	BaseRewardsPerEpoch      uint64 `protobuf:"varint,304,opt,name=BaseRewardsPerEpoch,proto3" json:"BaseRewardsPerEpoch,omitempty"`
	DepositContractTreeDepth uint64 `protobuf:"varint,305,opt,name=DepositContractTreeDepth,proto3" json:"DepositContractTreeDepth,omitempty"`
	// state list lengths
	EpochsPerHistoricalVector uint64 `protobuf:"varint,400,opt,name=EpochsPerHistoricalVector,proto3" json:"EpochsPerHistoricalVector,omitempty"`
	EpochsPerSlashingVector   uint64 `protobuf:"varint,401,opt,name=EpochsPerSlashingVector,proto3" json:"EpochsPerSlashingVector,omitempty"`
	HistoricalRootsLimit      uint64 `protobuf:"varint,402,opt,name=HistoricalRootsLimit,proto3" json:"HistoricalRootsLimit,omitempty"`
	ValidatorRegistryLimit    uint64 `protobuf:"varint,403,opt,name=ValidatorRegistryLimit,proto3" json:"ValidatorRegistryLimit,omitempty"`
	// rewards and penalties
	BaseRewardFactor             uint64 `protobuf:"varint,500,opt,name=BaseRewardFactor,proto3" json:"BaseRewardFactor,omitempty"`
	DKGReward                    uint64 `protobuf:"varint,501,opt,name=DKGReward,proto3" json:"DKGReward,omitempty"`
	BaseEth2DutyReward           uint64 `protobuf:"varint,502,opt,name=BaseEth2DutyReward,proto3" json:"BaseEth2DutyReward,omitempty"`
	MinSlashingPenaltyQuotient   uint64 `protobuf:"varint,503,opt,name=MinSlashingPenaltyQuotient,proto3" json:"MinSlashingPenaltyQuotient,omitempty"`
	WhitstleblowerRewardQuotient uint64 `protobuf:"varint,504,opt,name=WhitstleblowerRewardQuotient,proto3" json:"WhitstleblowerRewardQuotient,omitempty"`
	ProposerRewardQuotient       uint64 `protobuf:"varint,505,opt,name=ProposerRewardQuotient,proto3" json:"ProposerRewardQuotient,omitempty"`
	InactivityPenaltyQuotient    uint64 `protobuf:"varint,506,opt,name=InactivityPenaltyQuotient,proto3" json:"InactivityPenaltyQuotient,omitempty"`
	// domain
	DomainBeaconProposer    []byte `protobuf:"bytes,600,opt,name=DomainBeaconProposer,proto3" json:"DomainBeaconProposer,omitempty"`
	DomainBeaconAttester    []byte `protobuf:"bytes,601,opt,name=DomainBeaconAttester,proto3" json:"DomainBeaconAttester,omitempty"`
	DomainRandao            []byte `protobuf:"bytes,602,opt,name=DomainRandao,proto3" json:"DomainRandao,omitempty"`
	DomainDeposit           []byte `protobuf:"bytes,603,opt,name=DomainDeposit,proto3" json:"DomainDeposit,omitempty"`
	DomainVoluntaryExit     []byte `protobuf:"bytes,604,opt,name=DomainVoluntaryExit,proto3" json:"DomainVoluntaryExit,omitempty"`
	DomainSelectionProof    []byte `protobuf:"bytes,605,opt,name=DomainSelectionProof,proto3" json:"DomainSelectionProof,omitempty"`
	DomainAggregateAndProof []byte `protobuf:"bytes,606,opt,name=DomainAggregateAndProof,proto3" json:"DomainAggregateAndProof,omitempty"`
	// Gwei values
	MaxEffectiveBalance       uint64 `protobuf:"varint,700,opt,name=MaxEffectiveBalance,proto3" json:"MaxEffectiveBalance,omitempty"`
	EffectiveBalanceIncrement uint64 `protobuf:"varint,701,opt,name=EffectiveBalanceIncrement,proto3" json:"EffectiveBalanceIncrement,omitempty"`
	EjectionBalance           uint64 `protobuf:"varint,702,opt,name=EjectionBalance,proto3" json:"EjectionBalance,omitempty"`
	// Max operations per block
	MaxProposerSlashings uint64   `protobuf:"varint,800,opt,name=MaxProposerSlashings,proto3" json:"MaxProposerSlashings,omitempty"`
	MaxAttesterSlashings uint64   `protobuf:"varint,801,opt,name=MaxAttesterSlashings,proto3" json:"MaxAttesterSlashings,omitempty"`
	MaxAttestations      uint64   `protobuf:"varint,802,opt,name=MaxAttestations,proto3" json:"MaxAttestations,omitempty"`
	MaxDeposits          uint64   `protobuf:"varint,803,opt,name=MaxDeposits,proto3" json:"MaxDeposits,omitempty"`
	MaxVoluntaryExits    uint64   `protobuf:"varint,804,opt,name=MaxVoluntaryExits,proto3" json:"MaxVoluntaryExits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChainConfig) Reset()         { *m = ChainConfig{} }
func (m *ChainConfig) String() string { return proto.CompactTextString(m) }
func (*ChainConfig) ProtoMessage()    {}
func (*ChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0189c35229c86e3, []int{0}
}
func (m *ChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainConfig.Merge(m, src)
}
func (m *ChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChainConfig proto.InternalMessageInfo

func (m *ChainConfig) GetGenesisForkVersion() []byte {
	if m != nil {
		return m.GenesisForkVersion
	}
	return nil
}

func (m *ChainConfig) GetSlotsInEpoch() uint64 {
	if m != nil {
		return m.SlotsInEpoch
	}
	return 0
}

func (m *ChainConfig) GetMinAttestationInclusionDelay() uint64 {
	if m != nil {
		return m.MinAttestationInclusionDelay
	}
	return 0
}

func (m *ChainConfig) GetMaxSeedLookahead() uint64 {
	if m != nil {
		return m.MaxSeedLookahead
	}
	return 0
}

func (m *ChainConfig) GetMinSeedLookahead() uint64 {
	if m != nil {
		return m.MinSeedLookahead
	}
	return 0
}

func (m *ChainConfig) GetSlotsPerHistoricalRoot() uint64 {
	if m != nil {
		return m.SlotsPerHistoricalRoot
	}
	return 0
}

func (m *ChainConfig) GetMinValidatorWithdrawabilityDelay() uint64 {
	if m != nil {
		return m.MinValidatorWithdrawabilityDelay
	}
	return 0
}

func (m *ChainConfig) GetMinEpochsToInactivityPenalty() uint64 {
	if m != nil {
		return m.MinEpochsToInactivityPenalty
	}
	return 0
}

func (m *ChainConfig) GetEpochsPerETH1VotingPeriod() uint64 {
	if m != nil {
		return m.EpochsPerETH1VotingPeriod
	}
	return 0
}

func (m *ChainConfig) GetShardCommitteePeriod() uint64 {
	if m != nil {
		return m.ShardCommitteePeriod
	}
	return 0
}

func (m *ChainConfig) GetMaxCommitteesPerSlot() uint64 {
	if m != nil {
		return m.MaxCommitteesPerSlot
	}
	return 0
}

func (m *ChainConfig) GetTargetCommitteeSize() uint64 {
	if m != nil {
		return m.TargetCommitteeSize
	}
	return 0
}

func (m *ChainConfig) GetMaxValidatorsPerCommittee() uint64 {
	if m != nil {
		return m.MaxValidatorsPerCommittee
	}
	return 0
}

func (m *ChainConfig) GetChurnLimitQuotient() uint64 {
	if m != nil {
		return m.ChurnLimitQuotient
	}
	return 0
}

func (m *ChainConfig) GetVaultSize() uint64 {
	if m != nil {
		return m.VaultSize
	}
	return 0
}

func (m *ChainConfig) GetMinPerEpochChurnLimit() uint64 {
	if m != nil {
		return m.MinPerEpochChurnLimit
	}
	return 0
}

func (m *ChainConfig) GetMinGenesisTime() uint64 {
	if m != nil {
		return m.MinGenesisTime
	}
	return 0
}

func (m *ChainConfig) GetMinGenesisActiveValidatorCount() uint64 {
	if m != nil {
		return m.MinGenesisActiveValidatorCount
	}
	return 0
}

func (m *ChainConfig) GetProportionalSlashingMultiplier() uint64 {
	if m != nil {
		return m.ProportionalSlashingMultiplier
	}
	return 0
}

func (m *ChainConfig) GetHysteresisQuotient() uint64 {
	if m != nil {
		return m.HysteresisQuotient
	}
	return 0
}

func (m *ChainConfig) GetHysteresisDownwardMultiplier() uint64 {
	if m != nil {
		return m.HysteresisDownwardMultiplier
	}
	return 0
}

func (m *ChainConfig) GetHysteresisUpwardMultiplier() uint64 {
	if m != nil {
		return m.HysteresisUpwardMultiplier
	}
	return 0
}

func (m *ChainConfig) GetShuffleRoundCount() uint64 {
	if m != nil {
		return m.ShuffleRoundCount
	}
	return 0
}

func (m *ChainConfig) GetFarFutureEpoch() uint64 {
	if m != nil {
		return m.FarFutureEpoch
	}
	return 0
}

func (m *ChainConfig) GetZeroHash() []byte {
	if m != nil {
		return m.ZeroHash
	}
	return nil
}

func (m *ChainConfig) GetGenesisSeed() []byte {
	if m != nil {
		return m.GenesisSeed
	}
	return nil
}

func (m *ChainConfig) GetGenesisEpoch() uint64 {
	if m != nil {
		return m.GenesisEpoch
	}
	return 0
}

func (m *ChainConfig) GetBaseRewardsPerEpoch() uint64 {
	if m != nil {
		return m.BaseRewardsPerEpoch
	}
	return 0
}

func (m *ChainConfig) GetDepositContractTreeDepth() uint64 {
	if m != nil {
		return m.DepositContractTreeDepth
	}
	return 0
}

func (m *ChainConfig) GetEpochsPerHistoricalVector() uint64 {
	if m != nil {
		return m.EpochsPerHistoricalVector
	}
	return 0
}

func (m *ChainConfig) GetEpochsPerSlashingVector() uint64 {
	if m != nil {
		return m.EpochsPerSlashingVector
	}
	return 0
}

func (m *ChainConfig) GetHistoricalRootsLimit() uint64 {
	if m != nil {
		return m.HistoricalRootsLimit
	}
	return 0
}

func (m *ChainConfig) GetValidatorRegistryLimit() uint64 {
	if m != nil {
		return m.ValidatorRegistryLimit
	}
	return 0
}

func (m *ChainConfig) GetBaseRewardFactor() uint64 {
	if m != nil {
		return m.BaseRewardFactor
	}
	return 0
}

func (m *ChainConfig) GetDKGReward() uint64 {
	if m != nil {
		return m.DKGReward
	}
	return 0
}

func (m *ChainConfig) GetBaseEth2DutyReward() uint64 {
	if m != nil {
		return m.BaseEth2DutyReward
	}
	return 0
}

func (m *ChainConfig) GetMinSlashingPenaltyQuotient() uint64 {
	if m != nil {
		return m.MinSlashingPenaltyQuotient
	}
	return 0
}

func (m *ChainConfig) GetWhitstleblowerRewardQuotient() uint64 {
	if m != nil {
		return m.WhitstleblowerRewardQuotient
	}
	return 0
}

func (m *ChainConfig) GetProposerRewardQuotient() uint64 {
	if m != nil {
		return m.ProposerRewardQuotient
	}
	return 0
}

func (m *ChainConfig) GetInactivityPenaltyQuotient() uint64 {
	if m != nil {
		return m.InactivityPenaltyQuotient
	}
	return 0
}

func (m *ChainConfig) GetDomainBeaconProposer() []byte {
	if m != nil {
		return m.DomainBeaconProposer
	}
	return nil
}

func (m *ChainConfig) GetDomainBeaconAttester() []byte {
	if m != nil {
		return m.DomainBeaconAttester
	}
	return nil
}

func (m *ChainConfig) GetDomainRandao() []byte {
	if m != nil {
		return m.DomainRandao
	}
	return nil
}

func (m *ChainConfig) GetDomainDeposit() []byte {
	if m != nil {
		return m.DomainDeposit
	}
	return nil
}

func (m *ChainConfig) GetDomainVoluntaryExit() []byte {
	if m != nil {
		return m.DomainVoluntaryExit
	}
	return nil
}

func (m *ChainConfig) GetDomainSelectionProof() []byte {
	if m != nil {
		return m.DomainSelectionProof
	}
	return nil
}

func (m *ChainConfig) GetDomainAggregateAndProof() []byte {
	if m != nil {
		return m.DomainAggregateAndProof
	}
	return nil
}

func (m *ChainConfig) GetMaxEffectiveBalance() uint64 {
	if m != nil {
		return m.MaxEffectiveBalance
	}
	return 0
}

func (m *ChainConfig) GetEffectiveBalanceIncrement() uint64 {
	if m != nil {
		return m.EffectiveBalanceIncrement
	}
	return 0
}

func (m *ChainConfig) GetEjectionBalance() uint64 {
	if m != nil {
		return m.EjectionBalance
	}
	return 0
}

func (m *ChainConfig) GetMaxProposerSlashings() uint64 {
	if m != nil {
		return m.MaxProposerSlashings
	}
	return 0
}

func (m *ChainConfig) GetMaxAttesterSlashings() uint64 {
	if m != nil {
		return m.MaxAttesterSlashings
	}
	return 0
}

func (m *ChainConfig) GetMaxAttestations() uint64 {
	if m != nil {
		return m.MaxAttestations
	}
	return 0
}

func (m *ChainConfig) GetMaxDeposits() uint64 {
	if m != nil {
		return m.MaxDeposits
	}
	return 0
}

func (m *ChainConfig) GetMaxVoluntaryExits() uint64 {
	if m != nil {
		return m.MaxVoluntaryExits
	}
	return 0
}

func init() {
	proto.RegisterType((*ChainConfig)(nil), "core.ChainConfig")
}

func init() { proto.RegisterFile("src/core/config.proto", fileDescriptor_d0189c35229c86e3) }

var fileDescriptor_d0189c35229c86e3 = []byte{
	// 1112 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x56, 0x49, 0x8f, 0x1b, 0x45,
	0x14, 0xc6, 0x61, 0x32, 0x82, 0xca, 0x00, 0xa1, 0x48, 0x86, 0x0a, 0x84, 0xd1, 0x10, 0x84, 0x08,
	0x20, 0x66, 0x94, 0x44, 0x80, 0x50, 0x40, 0x68, 0xc6, 0xf6, 0x2c, 0x10, 0x4b, 0xc6, 0x36, 0x8e,
	0x94, 0x5b, 0x4d, 0xf7, 0xb3, 0xbb, 0x32, 0xed, 0x2a, 0xab, 0xaa, 0x9a, 0xb1, 0xf9, 0x15, 0x2c,
	0x17, 0x8e, 0x6c, 0x47, 0xd6, 0x3b, 0x70, 0xe2, 0x10, 0xf6, 0xb0, 0x1c, 0xd8, 0x85, 0x86, 0xbf,
	0xc0, 0x7e, 0x42, 0xd5, 0xaf, 0xdd, 0x3d, 0xb6, 0xbb, 0x9d, 0x63, 0x7f, 0xcb, 0xab, 0xea, 0xf7,
	0xea, 0xbd, 0x2a, 0x72, 0xdc, 0x68, 0x6f, 0xd5, 0x53, 0x1a, 0x56, 0x3d, 0x25, 0x3b, 0xa2, 0xbb,
	0xd2, 0xd7, 0xca, 0x2a, 0x3a, 0xe7, 0xa0, 0x53, 0x1f, 0x2f, 0x92, 0x23, 0xe5, 0x80, 0x0b, 0x59,
	0x8e, 0x39, 0xba, 0x42, 0xe8, 0x26, 0x48, 0x30, 0xc2, 0x6c, 0x28, 0xbd, 0xdb, 0x06, 0x6d, 0x84,
	0x92, 0xac, 0xb4, 0x5c, 0x3a, 0xbd, 0xd0, 0xc8, 0x61, 0xe8, 0x29, 0xb2, 0xd0, 0x0c, 0x95, 0x35,
	0xdb, 0xb2, 0xda, 0x57, 0x5e, 0xc0, 0xfc, 0xe5, 0xd2, 0xe9, 0xb9, 0xc6, 0x18, 0x46, 0xd7, 0xc9,
	0xc9, 0x9a, 0x90, 0x6b, 0xd6, 0x82, 0xb1, 0xdc, 0x0a, 0x25, 0xb7, 0xa5, 0x17, 0x46, 0xce, 0x5e,
	0x81, 0x90, 0x0f, 0x19, 0xc4, 0x9e, 0x99, 0x1a, 0xfa, 0x00, 0x39, 0x5a, 0xe3, 0x83, 0x26, 0x80,
	0x7f, 0x41, 0xa9, 0x5d, 0x1e, 0x00, 0xf7, 0x59, 0x27, 0xf6, 0x4d, 0xe1, 0xb1, 0x56, 0xc8, 0x71,
	0x6d, 0x37, 0xd1, 0x4e, 0xe0, 0xf4, 0x11, 0xb2, 0x18, 0xef, 0xb5, 0x0e, 0x7a, 0x4b, 0x18, 0xab,
	0xb4, 0xf0, 0x78, 0xd8, 0x50, 0xca, 0xb2, 0x20, 0x76, 0x14, 0xb0, 0xf4, 0x29, 0xb2, 0x5c, 0x13,
	0xb2, 0xcd, 0x43, 0xe1, 0x73, 0xab, 0xf4, 0x45, 0x61, 0x03, 0x5f, 0xf3, 0x3d, 0xbe, 0x23, 0x42,
	0x61, 0x87, 0xf8, 0x5f, 0x22, 0x8e, 0x70, 0x4d, 0x5d, 0x92, 0x9f, 0x38, 0x57, 0xa6, 0xa5, 0xb6,
	0x25, 0xf7, 0xac, 0x78, 0x4e, 0xd8, 0x61, 0x1d, 0x24, 0x0f, 0xed, 0x90, 0x5d, 0x4e, 0xf3, 0x53,
	0xa8, 0xa1, 0x8f, 0x93, 0x13, 0x48, 0xd6, 0x41, 0x57, 0x5b, 0x5b, 0x67, 0xda, 0xca, 0x0a, 0xd9,
	0xad, 0x83, 0x16, 0xca, 0x67, 0xbb, 0x71, 0x80, 0x62, 0x01, 0x3d, 0x4b, 0x8e, 0x35, 0x03, 0xae,
	0xfd, 0xb2, 0xea, 0xf5, 0x84, 0xb5, 0x00, 0x89, 0x31, 0x8c, 0x8d, 0xb9, 0x1c, 0x3d, 0x47, 0x8e,
	0xd5, 0xf8, 0x20, 0x45, 0x5d, 0x5c, 0x97, 0x2b, 0x76, 0xa5, 0x84, 0xa6, 0x3c, 0x92, 0x9e, 0x21,
	0xb7, 0xb5, 0xb8, 0xee, 0x82, 0x4d, 0xa9, 0xa6, 0x78, 0x1e, 0xd8, 0x27, 0xe8, 0xc9, 0xe3, 0xe8,
	0x13, 0xe4, 0x44, 0x8d, 0x0f, 0xd2, 0x0c, 0xba, 0x50, 0xa9, 0x80, 0x7d, 0x8a, 0xc6, 0x62, 0x05,
	0x5d, 0x25, 0xb4, 0x1c, 0x44, 0x5a, 0x5e, 0x10, 0x3d, 0x61, 0x9f, 0x89, 0x94, 0x15, 0x20, 0x2d,
	0xfb, 0x0c, 0x7d, 0x39, 0x14, 0xbd, 0x8b, 0xdc, 0xd8, 0xe6, 0x51, 0x68, 0xe3, 0x8d, 0x7d, 0x8e,
	0xba, 0x0c, 0xa1, 0x0f, 0x93, 0xe3, 0x35, 0x21, 0x5d, 0x12, 0x5d, 0x36, 0x33, 0x3f, 0xfb, 0x02,
	0xa5, 0xf9, 0x2c, 0xbd, 0x8f, 0xdc, 0x5c, 0x13, 0x32, 0x69, 0xa0, 0x96, 0xe8, 0x01, 0xfb, 0x12,
	0xf5, 0x13, 0x30, 0xdd, 0x24, 0x4b, 0x19, 0xb2, 0xe6, 0xaa, 0x0c, 0xe9, 0x9f, 0x95, 0x55, 0x24,
	0x2d, 0xfb, 0x0a, 0x8d, 0xd7, 0x90, 0xb9, 0x40, 0x75, 0xad, 0xfa, 0x4a, 0xbb, 0x6e, 0xe2, 0x61,
	0x33, 0xe4, 0x26, 0x10, 0xb2, 0x5b, 0x8b, 0x42, 0x2b, 0xfa, 0xa1, 0x00, 0xcd, 0xae, 0x26, 0x81,
	0x66, 0xcb, 0x5c, 0x06, 0xb7, 0x86, 0xc6, 0x82, 0x76, 0x4b, 0xa5, 0x19, 0xfc, 0x3a, 0xc9, 0xe0,
	0x34, 0x45, 0xcb, 0xe4, 0x64, 0x86, 0x56, 0xd4, 0x9e, 0xdc, 0xe3, 0xda, 0x3f, 0xb0, 0xee, 0x37,
	0x68, 0x9d, 0x29, 0xa2, 0x4f, 0x92, 0x3b, 0x32, 0xfe, 0xd9, 0xfe, 0x44, 0x88, 0x6f, 0x31, 0xc4,
	0x0c, 0x09, 0x7d, 0x88, 0xdc, 0xda, 0x0c, 0xa2, 0x4e, 0x27, 0x84, 0x86, 0x8a, 0xa4, 0x8f, 0xb9,
	0xfb, 0x0e, 0x7d, 0xd3, 0x8c, 0x2b, 0xd0, 0x06, 0xd7, 0x1b, 0x91, 0x8d, 0x34, 0xe0, 0x28, 0x7b,
	0xeb, 0x10, 0x16, 0x68, 0x1c, 0xa6, 0x77, 0x92, 0x1b, 0x2e, 0x81, 0x56, 0x5b, 0xdc, 0x04, 0xec,
	0xed, 0x43, 0xf1, 0x60, 0x4c, 0x01, 0x7a, 0x37, 0x39, 0x92, 0xd4, 0xc4, 0x8d, 0x19, 0xf6, 0x0e,
	0xf2, 0x07, 0x31, 0x7a, 0x0f, 0x59, 0x48, 0x3e, 0x71, 0x99, 0x77, 0x71, 0x99, 0x31, 0xd0, 0xf5,
	0xc9, 0x3a, 0x37, 0xd0, 0x00, 0xf7, 0x53, 0x66, 0x74, 0x9e, 0xd8, 0x7b, 0xa8, 0xcd, 0xe3, 0xe8,
	0x79, 0xc2, 0x2a, 0xd0, 0x57, 0x46, 0xd8, 0xb2, 0x92, 0x56, 0x73, 0xcf, 0xb6, 0x34, 0x40, 0x05,
	0xfa, 0x36, 0x60, 0xef, 0xa3, 0xaf, 0x50, 0xe0, 0x9a, 0x2c, 0x9d, 0x0e, 0xd9, 0xa4, 0x6b, 0x83,
	0x67, 0x95, 0x66, 0x2f, 0x5c, 0x3f, 0x31, 0x3f, 0x26, 0x15, 0xf4, 0x31, 0x72, 0x7b, 0x4a, 0x8e,
	0x4e, 0x50, 0x62, 0x7e, 0x11, 0xcd, 0x45, 0xbc, 0x1b, 0x23, 0xe3, 0xa3, 0xd5, 0x60, 0x3b, 0xbd,
	0x84, 0xbe, 0x5c, 0x92, 0x3e, 0x4a, 0x16, 0xd3, 0xd3, 0xde, 0x80, 0xae, 0x30, 0x56, 0x0f, 0xd1,
	0xf6, 0x32, 0xda, 0x0a, 0x68, 0xfa, 0x20, 0x39, 0x9a, 0xe5, 0x6e, 0x83, 0xc7, 0x3b, 0xfc, 0x03,
	0x2d, 0x53, 0x84, 0x9b, 0x04, 0x95, 0xa7, 0x37, 0x11, 0x62, 0x7f, 0xa2, 0x2a, 0x43, 0x5c, 0x5f,
	0x38, 0x4b, 0xd5, 0x06, 0x67, 0x2b, 0x91, 0x1d, 0x26, 0xba, 0xbf, 0x50, 0x97, 0x43, 0xb9, 0x23,
	0xed, 0xee, 0x9f, 0xe4, 0xff, 0x93, 0xc9, 0x9d, 0x36, 0xd4, 0xdf, 0x68, 0x9c, 0x21, 0x71, 0x8d,
	0x75, 0x31, 0x10, 0xd6, 0xd8, 0x10, 0x76, 0x42, 0xb5, 0x07, 0x1a, 0x03, 0xa7, 0x21, 0xfe, 0xc1,
	0x10, 0x33, 0x45, 0x2e, 0x77, 0x71, 0xc3, 0x9b, 0x29, 0xfb, 0xbf, 0x49, 0xee, 0xf2, 0x69, 0x77,
	0x46, 0xa6, 0xee, 0x9d, 0xd4, 0xfb, 0x5f, 0x72, 0x46, 0x0a, 0x15, 0xae, 0xd0, 0x15, 0xd5, 0xe3,
	0x42, 0xae, 0x03, 0xf7, 0x94, 0x1c, 0x2d, 0xc2, 0xbe, 0x9f, 0x8b, 0x7b, 0x24, 0x97, 0x9c, 0x34,
	0xe1, 0xfb, 0x00, 0x34, 0xfb, 0x21, 0xc7, 0x34, 0x22, 0x5d, 0x87, 0x21, 0xde, 0xe0, 0xd2, 0xe7,
	0x8a, 0xfd, 0x88, 0xe2, 0x31, 0x90, 0xde, 0x4b, 0x6e, 0xc2, 0xef, 0xa4, 0x27, 0xd8, 0x4f, 0xa8,
	0x1a, 0x47, 0x5d, 0x23, 0x22, 0xd0, 0x56, 0x61, 0x24, 0x2d, 0xd7, 0xc3, 0xea, 0x40, 0x58, 0xf6,
	0x33, 0x8a, 0xf3, 0xb8, 0x6c, 0xcf, 0x4d, 0x08, 0xc1, 0x73, 0x63, 0xb5, 0xae, 0x95, 0xea, 0xb0,
	0x5f, 0xc6, 0xf6, 0x3c, 0x4e, 0xba, 0x0e, 0x42, 0x7c, 0xad, 0xdb, 0xd5, 0xd0, 0xe5, 0x16, 0xd6,
	0xa4, 0x8f, 0xbe, 0x5f, 0xd1, 0x57, 0xc4, 0xbb, 0x2d, 0xd6, 0xf8, 0xa0, 0xda, 0xe9, 0x40, 0x7c,
	0x0d, 0xac, 0xf3, 0x90, 0x4b, 0x0f, 0xd8, 0x07, 0x87, 0x71, 0x56, 0xe4, 0x70, 0x71, 0xbb, 0x4f,
	0x60, 0xdb, 0xd2, 0xd3, 0xd0, 0x73, 0xa5, 0xfc, 0xf0, 0x70, 0xd2, 0xee, 0x45, 0x0a, 0x7a, 0x3f,
	0xb9, 0xa5, 0x7a, 0x19, 0x77, 0x3f, 0x5a, 0xed, 0x23, 0x34, 0x4d, 0xe2, 0xc9, 0x2b, 0x61, 0x54,
	0xcf, 0xd1, 0xc1, 0x36, 0xec, 0xd5, 0xf9, 0xf4, 0x95, 0x30, 0x45, 0x26, 0xa6, 0x51, 0x3d, 0x33,
	0xd3, 0x6b, 0x99, 0x69, 0x8a, 0x74, 0x9b, 0x4a, 0xf1, 0xf8, 0x05, 0x69, 0xd8, 0xeb, 0xa8, 0x9f,
	0xc4, 0xdd, 0x94, 0xae, 0xf1, 0x41, 0x52, 0x62, 0xc3, 0xde, 0x40, 0xd9, 0x41, 0xcc, 0xdd, 0x1e,
	0xee, 0x4d, 0x71, 0xb0, 0xb0, 0x86, 0xbd, 0x89, 0xc2, 0x69, 0x66, 0x9d, 0x5d, 0xd9, 0x5f, 0x2a,
	0x5d, 0xdd, 0x5f, 0x2a, 0xfd, 0xb6, 0xbf, 0x54, 0x7a, 0xe5, 0xf7, 0xa5, 0xeb, 0x2e, 0xcd, 0xaf,
	0x9c, 0x77, 0x0f, 0xec, 0x9d, 0xf9, 0xf8, 0xb5, 0x7d, 0xee, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x11, 0x0a, 0xd0, 0xe0, 0x86, 0x0b, 0x00, 0x00,
}

func (m *ChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxVoluntaryExits != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxVoluntaryExits))
		i--
		dAtA[i] = 0x32
		i--
		dAtA[i] = 0xa0
	}
	if m.MaxDeposits != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxDeposits))
		i--
		dAtA[i] = 0x32
		i--
		dAtA[i] = 0x98
	}
	if m.MaxAttestations != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxAttestations))
		i--
		dAtA[i] = 0x32
		i--
		dAtA[i] = 0x90
	}
	if m.MaxAttesterSlashings != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxAttesterSlashings))
		i--
		dAtA[i] = 0x32
		i--
		dAtA[i] = 0x88
	}
	if m.MaxProposerSlashings != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxProposerSlashings))
		i--
		dAtA[i] = 0x32
		i--
		dAtA[i] = 0x80
	}
	if m.EjectionBalance != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.EjectionBalance))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf0
	}
	if m.EffectiveBalanceIncrement != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.EffectiveBalanceIncrement))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xe8
	}
	if m.MaxEffectiveBalance != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxEffectiveBalance))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xe0
	}
	if len(m.DomainAggregateAndProof) > 0 {
		i -= len(m.DomainAggregateAndProof)
		copy(dAtA[i:], m.DomainAggregateAndProof)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainAggregateAndProof)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xf2
	}
	if len(m.DomainSelectionProof) > 0 {
		i -= len(m.DomainSelectionProof)
		copy(dAtA[i:], m.DomainSelectionProof)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainSelectionProof)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xea
	}
	if len(m.DomainVoluntaryExit) > 0 {
		i -= len(m.DomainVoluntaryExit)
		copy(dAtA[i:], m.DomainVoluntaryExit)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainVoluntaryExit)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xe2
	}
	if len(m.DomainDeposit) > 0 {
		i -= len(m.DomainDeposit)
		copy(dAtA[i:], m.DomainDeposit)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainDeposit)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xda
	}
	if len(m.DomainRandao) > 0 {
		i -= len(m.DomainRandao)
		copy(dAtA[i:], m.DomainRandao)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainRandao)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xd2
	}
	if len(m.DomainBeaconAttester) > 0 {
		i -= len(m.DomainBeaconAttester)
		copy(dAtA[i:], m.DomainBeaconAttester)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainBeaconAttester)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xca
	}
	if len(m.DomainBeaconProposer) > 0 {
		i -= len(m.DomainBeaconProposer)
		copy(dAtA[i:], m.DomainBeaconProposer)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DomainBeaconProposer)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xc2
	}
	if m.InactivityPenaltyQuotient != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.InactivityPenaltyQuotient))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xd0
	}
	if m.ProposerRewardQuotient != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ProposerRewardQuotient))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xc8
	}
	if m.WhitstleblowerRewardQuotient != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.WhitstleblowerRewardQuotient))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xc0
	}
	if m.MinSlashingPenaltyQuotient != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinSlashingPenaltyQuotient))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xb8
	}
	if m.BaseEth2DutyReward != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.BaseEth2DutyReward))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xb0
	}
	if m.DKGReward != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.DKGReward))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xa8
	}
	if m.BaseRewardFactor != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.BaseRewardFactor))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xa0
	}
	if m.ValidatorRegistryLimit != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ValidatorRegistryLimit))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x98
	}
	if m.HistoricalRootsLimit != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.HistoricalRootsLimit))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x90
	}
	if m.EpochsPerSlashingVector != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.EpochsPerSlashingVector))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x88
	}
	if m.EpochsPerHistoricalVector != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.EpochsPerHistoricalVector))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x80
	}
	if m.DepositContractTreeDepth != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.DepositContractTreeDepth))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x88
	}
	if m.BaseRewardsPerEpoch != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.BaseRewardsPerEpoch))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x80
	}
	if m.GenesisEpoch != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.GenesisEpoch))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xf8
	}
	if len(m.GenesisSeed) > 0 {
		i -= len(m.GenesisSeed)
		copy(dAtA[i:], m.GenesisSeed)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.GenesisSeed)))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xf2
	}
	if len(m.ZeroHash) > 0 {
		i -= len(m.ZeroHash)
		copy(dAtA[i:], m.ZeroHash)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ZeroHash)))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xea
	}
	if m.FarFutureEpoch != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.FarFutureEpoch))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xe0
	}
	if m.ShuffleRoundCount != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ShuffleRoundCount))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xa0
	}
	if m.HysteresisUpwardMultiplier != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.HysteresisUpwardMultiplier))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x98
	}
	if m.HysteresisDownwardMultiplier != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.HysteresisDownwardMultiplier))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x90
	}
	if m.HysteresisQuotient != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.HysteresisQuotient))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x88
	}
	if m.ProportionalSlashingMultiplier != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ProportionalSlashingMultiplier))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x80
	}
	if m.MinGenesisActiveValidatorCount != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinGenesisActiveValidatorCount))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf8
	}
	if m.MinGenesisTime != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinGenesisTime))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf0
	}
	if m.MinPerEpochChurnLimit != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinPerEpochChurnLimit))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe8
	}
	if m.VaultSize != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.VaultSize))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe0
	}
	if m.ChurnLimitQuotient != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ChurnLimitQuotient))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd8
	}
	if m.MaxValidatorsPerCommittee != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxValidatorsPerCommittee))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd0
	}
	if m.TargetCommitteeSize != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.TargetCommitteeSize))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxCommitteesPerSlot != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxCommitteesPerSlot))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc0
	}
	if m.ShardCommitteePeriod != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ShardCommitteePeriod))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe0
	}
	if m.EpochsPerETH1VotingPeriod != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.EpochsPerETH1VotingPeriod))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd8
	}
	if m.MinEpochsToInactivityPenalty != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinEpochsToInactivityPenalty))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd0
	}
	if m.MinValidatorWithdrawabilityDelay != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinValidatorWithdrawabilityDelay))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc8
	}
	if m.SlotsPerHistoricalRoot != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.SlotsPerHistoricalRoot))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc0
	}
	if m.MinSeedLookahead != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinSeedLookahead))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if m.MaxSeedLookahead != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxSeedLookahead))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.MinAttestationInclusionDelay != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MinAttestationInclusionDelay))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.SlotsInEpoch != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.SlotsInEpoch))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.GenesisForkVersion) > 0 {
		i -= len(m.GenesisForkVersion)
		copy(dAtA[i:], m.GenesisForkVersion)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.GenesisForkVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GenesisForkVersion)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.SlotsInEpoch != 0 {
		n += 2 + sovConfig(uint64(m.SlotsInEpoch))
	}
	if m.MinAttestationInclusionDelay != 0 {
		n += 2 + sovConfig(uint64(m.MinAttestationInclusionDelay))
	}
	if m.MaxSeedLookahead != 0 {
		n += 2 + sovConfig(uint64(m.MaxSeedLookahead))
	}
	if m.MinSeedLookahead != 0 {
		n += 2 + sovConfig(uint64(m.MinSeedLookahead))
	}
	if m.SlotsPerHistoricalRoot != 0 {
		n += 2 + sovConfig(uint64(m.SlotsPerHistoricalRoot))
	}
	if m.MinValidatorWithdrawabilityDelay != 0 {
		n += 2 + sovConfig(uint64(m.MinValidatorWithdrawabilityDelay))
	}
	if m.MinEpochsToInactivityPenalty != 0 {
		n += 2 + sovConfig(uint64(m.MinEpochsToInactivityPenalty))
	}
	if m.EpochsPerETH1VotingPeriod != 0 {
		n += 2 + sovConfig(uint64(m.EpochsPerETH1VotingPeriod))
	}
	if m.ShardCommitteePeriod != 0 {
		n += 2 + sovConfig(uint64(m.ShardCommitteePeriod))
	}
	if m.MaxCommitteesPerSlot != 0 {
		n += 2 + sovConfig(uint64(m.MaxCommitteesPerSlot))
	}
	if m.TargetCommitteeSize != 0 {
		n += 2 + sovConfig(uint64(m.TargetCommitteeSize))
	}
	if m.MaxValidatorsPerCommittee != 0 {
		n += 2 + sovConfig(uint64(m.MaxValidatorsPerCommittee))
	}
	if m.ChurnLimitQuotient != 0 {
		n += 2 + sovConfig(uint64(m.ChurnLimitQuotient))
	}
	if m.VaultSize != 0 {
		n += 2 + sovConfig(uint64(m.VaultSize))
	}
	if m.MinPerEpochChurnLimit != 0 {
		n += 2 + sovConfig(uint64(m.MinPerEpochChurnLimit))
	}
	if m.MinGenesisTime != 0 {
		n += 2 + sovConfig(uint64(m.MinGenesisTime))
	}
	if m.MinGenesisActiveValidatorCount != 0 {
		n += 2 + sovConfig(uint64(m.MinGenesisActiveValidatorCount))
	}
	if m.ProportionalSlashingMultiplier != 0 {
		n += 2 + sovConfig(uint64(m.ProportionalSlashingMultiplier))
	}
	if m.HysteresisQuotient != 0 {
		n += 2 + sovConfig(uint64(m.HysteresisQuotient))
	}
	if m.HysteresisDownwardMultiplier != 0 {
		n += 2 + sovConfig(uint64(m.HysteresisDownwardMultiplier))
	}
	if m.HysteresisUpwardMultiplier != 0 {
		n += 2 + sovConfig(uint64(m.HysteresisUpwardMultiplier))
	}
	if m.ShuffleRoundCount != 0 {
		n += 2 + sovConfig(uint64(m.ShuffleRoundCount))
	}
	if m.FarFutureEpoch != 0 {
		n += 2 + sovConfig(uint64(m.FarFutureEpoch))
	}
	l = len(m.ZeroHash)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.GenesisSeed)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	if m.GenesisEpoch != 0 {
		n += 2 + sovConfig(uint64(m.GenesisEpoch))
	}
	if m.BaseRewardsPerEpoch != 0 {
		n += 2 + sovConfig(uint64(m.BaseRewardsPerEpoch))
	}
	if m.DepositContractTreeDepth != 0 {
		n += 2 + sovConfig(uint64(m.DepositContractTreeDepth))
	}
	if m.EpochsPerHistoricalVector != 0 {
		n += 2 + sovConfig(uint64(m.EpochsPerHistoricalVector))
	}
	if m.EpochsPerSlashingVector != 0 {
		n += 2 + sovConfig(uint64(m.EpochsPerSlashingVector))
	}
	if m.HistoricalRootsLimit != 0 {
		n += 2 + sovConfig(uint64(m.HistoricalRootsLimit))
	}
	if m.ValidatorRegistryLimit != 0 {
		n += 2 + sovConfig(uint64(m.ValidatorRegistryLimit))
	}
	if m.BaseRewardFactor != 0 {
		n += 2 + sovConfig(uint64(m.BaseRewardFactor))
	}
	if m.DKGReward != 0 {
		n += 2 + sovConfig(uint64(m.DKGReward))
	}
	if m.BaseEth2DutyReward != 0 {
		n += 2 + sovConfig(uint64(m.BaseEth2DutyReward))
	}
	if m.MinSlashingPenaltyQuotient != 0 {
		n += 2 + sovConfig(uint64(m.MinSlashingPenaltyQuotient))
	}
	if m.WhitstleblowerRewardQuotient != 0 {
		n += 2 + sovConfig(uint64(m.WhitstleblowerRewardQuotient))
	}
	if m.ProposerRewardQuotient != 0 {
		n += 2 + sovConfig(uint64(m.ProposerRewardQuotient))
	}
	if m.InactivityPenaltyQuotient != 0 {
		n += 2 + sovConfig(uint64(m.InactivityPenaltyQuotient))
	}
	l = len(m.DomainBeaconProposer)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.DomainBeaconAttester)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.DomainRandao)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.DomainDeposit)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.DomainVoluntaryExit)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.DomainSelectionProof)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	l = len(m.DomainAggregateAndProof)
	if l > 0 {
		n += 2 + l + sovConfig(uint64(l))
	}
	if m.MaxEffectiveBalance != 0 {
		n += 2 + sovConfig(uint64(m.MaxEffectiveBalance))
	}
	if m.EffectiveBalanceIncrement != 0 {
		n += 2 + sovConfig(uint64(m.EffectiveBalanceIncrement))
	}
	if m.EjectionBalance != 0 {
		n += 2 + sovConfig(uint64(m.EjectionBalance))
	}
	if m.MaxProposerSlashings != 0 {
		n += 2 + sovConfig(uint64(m.MaxProposerSlashings))
	}
	if m.MaxAttesterSlashings != 0 {
		n += 2 + sovConfig(uint64(m.MaxAttesterSlashings))
	}
	if m.MaxAttestations != 0 {
		n += 2 + sovConfig(uint64(m.MaxAttestations))
	}
	if m.MaxDeposits != 0 {
		n += 2 + sovConfig(uint64(m.MaxDeposits))
	}
	if m.MaxVoluntaryExits != 0 {
		n += 2 + sovConfig(uint64(m.MaxVoluntaryExits))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConfig(x uint64) (n int) {
	return sovConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisForkVersion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisForkVersion = append(m.GenesisForkVersion[:0], dAtA[iNdEx:postIndex]...)
			if m.GenesisForkVersion == nil {
				m.GenesisForkVersion = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotsInEpoch", wireType)
			}
			m.SlotsInEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotsInEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAttestationInclusionDelay", wireType)
			}
			m.MinAttestationInclusionDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAttestationInclusionDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSeedLookahead", wireType)
			}
			m.MaxSeedLookahead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSeedLookahead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSeedLookahead", wireType)
			}
			m.MinSeedLookahead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSeedLookahead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotsPerHistoricalRoot", wireType)
			}
			m.SlotsPerHistoricalRoot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotsPerHistoricalRoot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValidatorWithdrawabilityDelay", wireType)
			}
			m.MinValidatorWithdrawabilityDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValidatorWithdrawabilityDelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEpochsToInactivityPenalty", wireType)
			}
			m.MinEpochsToInactivityPenalty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinEpochsToInactivityPenalty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 107:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochsPerETH1VotingPeriod", wireType)
			}
			m.EpochsPerETH1VotingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochsPerETH1VotingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCommitteePeriod", wireType)
			}
			m.ShardCommitteePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCommitteePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCommitteesPerSlot", wireType)
			}
			m.MaxCommitteesPerSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCommitteesPerSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCommitteeSize", wireType)
			}
			m.TargetCommitteeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetCommitteeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValidatorsPerCommittee", wireType)
			}
			m.MaxValidatorsPerCommittee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValidatorsPerCommittee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 203:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChurnLimitQuotient", wireType)
			}
			m.ChurnLimitQuotient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChurnLimitQuotient |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 204:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSize", wireType)
			}
			m.VaultSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 205:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPerEpochChurnLimit", wireType)
			}
			m.MinPerEpochChurnLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPerEpochChurnLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 206:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGenesisTime", wireType)
			}
			m.MinGenesisTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinGenesisTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 207:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGenesisActiveValidatorCount", wireType)
			}
			m.MinGenesisActiveValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinGenesisActiveValidatorCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 208:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProportionalSlashingMultiplier", wireType)
			}
			m.ProportionalSlashingMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProportionalSlashingMultiplier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 209:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HysteresisQuotient", wireType)
			}
			m.HysteresisQuotient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HysteresisQuotient |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 210:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HysteresisDownwardMultiplier", wireType)
			}
			m.HysteresisDownwardMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HysteresisDownwardMultiplier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 211:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HysteresisUpwardMultiplier", wireType)
			}
			m.HysteresisUpwardMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HysteresisUpwardMultiplier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 212:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRoundCount", wireType)
			}
			m.ShuffleRoundCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleRoundCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 300:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarFutureEpoch", wireType)
			}
			m.FarFutureEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FarFutureEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZeroHash = append(m.ZeroHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ZeroHash == nil {
				m.ZeroHash = []byte{}
			}
			iNdEx = postIndex
		case 302:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisSeed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisSeed = append(m.GenesisSeed[:0], dAtA[iNdEx:postIndex]...)
			if m.GenesisSeed == nil {
				m.GenesisSeed = []byte{}
			}
			iNdEx = postIndex
		case 303:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisEpoch", wireType)
			}
			m.GenesisEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 304:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRewardsPerEpoch", wireType)
			}
			m.BaseRewardsPerEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRewardsPerEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 305:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositContractTreeDepth", wireType)
			}
			m.DepositContractTreeDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositContractTreeDepth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 400:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochsPerHistoricalVector", wireType)
			}
			m.EpochsPerHistoricalVector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochsPerHistoricalVector |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 401:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochsPerSlashingVector", wireType)
			}
			m.EpochsPerSlashingVector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochsPerSlashingVector |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 402:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalRootsLimit", wireType)
			}
			m.HistoricalRootsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoricalRootsLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 403:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorRegistryLimit", wireType)
			}
			m.ValidatorRegistryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorRegistryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 500:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRewardFactor", wireType)
			}
			m.BaseRewardFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRewardFactor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 501:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DKGReward", wireType)
			}
			m.DKGReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DKGReward |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 502:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseEth2DutyReward", wireType)
			}
			m.BaseEth2DutyReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseEth2DutyReward |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 503:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSlashingPenaltyQuotient", wireType)
			}
			m.MinSlashingPenaltyQuotient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSlashingPenaltyQuotient |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 504:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhitstleblowerRewardQuotient", wireType)
			}
			m.WhitstleblowerRewardQuotient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhitstleblowerRewardQuotient |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 505:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerRewardQuotient", wireType)
			}
			m.ProposerRewardQuotient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerRewardQuotient |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 506:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactivityPenaltyQuotient", wireType)
			}
			m.InactivityPenaltyQuotient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactivityPenaltyQuotient |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 600:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainBeaconProposer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainBeaconProposer = append(m.DomainBeaconProposer[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainBeaconProposer == nil {
				m.DomainBeaconProposer = []byte{}
			}
			iNdEx = postIndex
		case 601:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainBeaconAttester", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainBeaconAttester = append(m.DomainBeaconAttester[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainBeaconAttester == nil {
				m.DomainBeaconAttester = []byte{}
			}
			iNdEx = postIndex
		case 602:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainRandao", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainRandao = append(m.DomainRandao[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainRandao == nil {
				m.DomainRandao = []byte{}
			}
			iNdEx = postIndex
		case 603:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainDeposit", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainDeposit = append(m.DomainDeposit[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainDeposit == nil {
				m.DomainDeposit = []byte{}
			}
			iNdEx = postIndex
		case 604:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainVoluntaryExit", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainVoluntaryExit = append(m.DomainVoluntaryExit[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainVoluntaryExit == nil {
				m.DomainVoluntaryExit = []byte{}
			}
			iNdEx = postIndex
		case 605:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainSelectionProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainSelectionProof = append(m.DomainSelectionProof[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainSelectionProof == nil {
				m.DomainSelectionProof = []byte{}
			}
			iNdEx = postIndex
		case 606:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainAggregateAndProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainAggregateAndProof = append(m.DomainAggregateAndProof[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainAggregateAndProof == nil {
				m.DomainAggregateAndProof = []byte{}
			}
			iNdEx = postIndex
		case 700:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEffectiveBalance", wireType)
			}
			m.MaxEffectiveBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEffectiveBalance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 701:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveBalanceIncrement", wireType)
			}
			m.EffectiveBalanceIncrement = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveBalanceIncrement |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 702:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EjectionBalance", wireType)
			}
			m.EjectionBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EjectionBalance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 800:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProposerSlashings", wireType)
			}
			m.MaxProposerSlashings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProposerSlashings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 801:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttesterSlashings", wireType)
			}
			m.MaxAttesterSlashings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttesterSlashings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 802:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttestations", wireType)
			}
			m.MaxAttestations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttestations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 803:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeposits", wireType)
			}
			m.MaxDeposits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDeposits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 804:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVoluntaryExits", wireType)
			}
			m.MaxVoluntaryExits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxVoluntaryExits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConfig = fmt.Errorf("proto: unexpected end of group")
)
